---
id: article2
title: AmateursCTF2023 Writeup
description: AmateursCTF 2023のwriteup
date: '2023-8-4'
categories:
  - cyber security
  - ctf
  - writeup
  - amateurs
published: true
---

AmateursCTF 2023に参加したので解いた問題のwriteupを書く。
<br>

## Compact XORs

以下の暗号文が与えられた。

```610c6115651072014317463d73127613732c73036102653a6217742b701c61086e1a651d742b69075f2f6c0d69075f2c690e681c5f673604650364023944```   

問題名から上記の値をxorに関連する処理を行うことで解読ができそうだ。
暗号文の文頭がamateursCTF`{`で始まると仮定する。
暗号文の文頭12文字とamateursCTF`{`を一文字ずつxorしてみる。  

```python
c = "610c6115651072014317463d73127613732c73036102653a6217742b701c61086e1a651d742b69075f2f6c0d69075f2c690e681c5f673604650364023944"
f = b"amateursCTF{"
o = ""
c = bytes.fromhex(c)

for i in range(len(f)):
    print(c[i],f[i]) 
```
結果は以下になった。
```
97 97
12 109
97 97
21 116
101 101
16 117
114 114
1 115
67 67
23 84
70 70
61 123
```
このことから奇数番目の平文と暗号文のxorは0になりそうなことがわかる。つまり平文は0と暗号文のxorで求めることができそうだ。
しかしまだ偶数番目についてがわからない。
試しに、xorしてみる。
```python
c = "610c6115651072014317463d73127613732c73036102653a6217742b701c61086e1a651d742b69075f2f6c0d69075f2c690e681c5f673604650364023944"
f = b"amateursCTF{"

c = bytes.fromhex(c)

count = 0
o = ""

for i in range(len(f)):
    print(c[i],f[i],c[i] ^ f[i])
 
print(o)
```
これの結果は以下になる。
```
97 97 0
12 109 97
97 97 0
21 116 97
101 101 0
16 117 101
114 114 0
1 115 114
67 67 0
23 84 67
70 70 0
61 123 70
```
結果からわかるように、偶数番目同士をxorした結果がいつでもその一つ前の平文と等しい。したがって、偶数番目の平文は、暗号文と一つ前の平分のxorで求めることができる。
ここまでのことを踏まえてexploitは以下のようになる。
```python
c = "610c6115651072014317463d73127613732c73036102653a6217742b701c61086e1a651d742b69075f2f6c0d69075f2c690e681c5f673604650364023944"

c = bytes.fromhex(c)

count = 0
o = ""
for i in range(len(c)):
    if count % 2 == 0:
        o+= chr(c[i] ^ 0)
    else:
        o+= chr(c[i] ^ (c[i-1] ^ 0))
    count += 1

print(o)
```  
<br>

## You get extra information 1 
output.txtとmain.pyが与えられる。
それぞれの内容は以下の通り。
```
#output.txt
n: 83790217241770949930785127822292134633736157973099853931383028198485119939022553589863171712515159590920355561620948287649289302675837892832944404211978967792836179441682795846147312001618564075776280810972021418434978269714364099297666710830717154344277019791039237445921454207967552782769647647208575607201
c: 55170985485931992412061493588380213138061989158987480264288581679930785576529127257790549531229734149688212171710561151529495719876972293968746590202214939126736042529012383384602168155329599794302309463019364103314820346709676184132071708770466649702573831970710420398772142142828226424536566463017178086577
e: 65537
extra_information: 26565552874478429895594150715835574472819014534271940714512961970223616824812349678207505829777946867252164956116701692701674023296773659395833735044077013⏎
```
```python
#main.py
from Crypto.Util.number import *
import gmpy2

from flag import flag

p = getPrime(512)
q = getPrime(512)
n = p * q
e = 0x10001

f = p + q
extra_information = f + q
ptxt = bytes_to_long(flag)
c = pow(ptxt, e, n)

print("q: ", q)
print(f"n: {n}\nc: {c}\ne: {e}\nextra_information: {extra_information}")
```
通常のrsaの公開鍵として入手できる、$n,e$ に加えて、余分な情報が与えられるから、そこから秘密鍵を当てる問題。
まずextra_informationがどのような値なのか見てみる。 
```python
f = p + q
extra_information = f + q
```
なのでextra_informationを $x$ とすると $x = 2q + p$ となる。
ここからは簡単な式変形と方程式で $p,q$ を求めることができる。  

rsaの定義より、  
$n=pq$  

$x=2q+p$ より  
$p=x-2q$

したがって  

$n=(x-2q)q$  

$n=-2q^2+qx$  

$2q^2-qx+n=0$

二次方程式の解の公式より  

$q=\frac{x +- \sqrt{x^2-8n}}{4}$

これで `q` が求まったので $p=\frac{n}{q}$ でpも求まる。よってexploitは以下のようになる。 
```python 
import gmpy2
from Crypto.Util.number import inverse, long_to_bytes

n = 83790217241770949930785127822292134633736157973099853931383028198485119939022553589863171712515159590920355561620948287649289302675837892832944404211978967792836179441682795846147312001618564075776280810972021418434978269714364099297666710830717154344277019791039237445921454207967552782769647647208575607201
c = 55170985485931992412061493588380213138061989158987480264288581679930785576529127257790549531229734149688212171710561151529495719876972293968746590202214939126736042529012383384602168155329599794302309463019364103314820346709676184132071708770466649702573831970710420398772142142828226424536566463017178086577
e = 65537
x = 26565552874478429895594150715835574472819014534271940714512961970223616824812349678207505829777946867252164956116701692701674023296773659395833735044077013

q = (x + gmpy2.isqrt(x**2 - (8 * n))) // 4
p = n // q

d = inverse(e, (p - 1) * (q - 1))

pn = pow(c, d, n)
print(long_to_bytes(pn))
```
<br>

## You get extra information 2
You get extra information 1 と問題の系統は同じ。  
今回与えられたのは

```
#flag.txt
n: 95593382112797270045497836514999308524326160650345266525670495575191979116591752182138270308274446464071024826510473429700676303637674960212123982700153540490805215151070356646141514736282385755143090035980011032465519861526291865888128545478530962058792257703950616556136479933021373472378679162332202365371  
c: 92084942302809419329882275131365664619817865820237979575321652348851871468885232665120732298048355621943772250718055278615366362227084559410831820721620242260588398786014654743749734106956509345330468686120026908164376320923131751798117799981744551407234489862207435686504148347452579942637697333568788391594  
e: 65537  
extra_information: 18247071175606431398122118602371784578875472790915317892207044424588309397797319375039984309368393267673885302107217184699052743790470091033147110959310433418937324145720036262540098007724458652548486534453030546582214242131458903058169536052488501597969216020092796160475487905223265691093061136660574497410399108890645909789835984721231354187679269066357591297035974333220513134895660609801438138623213711900681512310067292949714127564635579383633589101296120704659647911638787823818973909534106275908594589830353183557722172234952579827423906720754070119865452363350814918812923981729393142874903734028229195885438296963982680724071663211427931391032589901737528717167662646147224323491202696402122261699504048973334902281462240308032014697804531871922566779026958815207465755155123070196922127199447785648102152027431894178737946151518726929361221425189695069653652163012000609320105988830299015364692678902927254273154427301473090465612473379114039284029813071586214536353994345527805408387636097772645156970939979500155578289301143563369142329343932852167241705090287661795  

```
```python
#main.py
from Crypto.Util.number import *
import sympy
from flag import flag

p = getPrime(512)
q = getPrime(512)
n = p * q
e = 0x10001
extra_information = (n**2) * (p**3 + 5 * (p + 1) ** 2) + 5 * n * q + q**2
ptxt = bytes_to_long(flag)
c = pow(ptxt, e, n)
print(f"n: {n}\nc: {c}\ne: {e}\nextra_information: {extra_information}")
```

与えられたextra_informationを式にすると、 

$n^2[p^3+5(p+1)^2]+5nq+q^2$ 

式変形をして、$q=\frac{n}{p}$ を代入すると  

$p^5n^2+5n^2p^4+10n^2p^5+5n^2p^2+5n^2p+n^2-p^2x=0$  

という５次方程式が作れる。次数が5以上の方程式の解の公式は存在しないことが知られているが、求める方法もある。5次方程式をとく公立の良いアルゴリズムを自分で実装するのは現実的ではないので、sympyというライブラリを使用した。sympyについてはググってください。最終的に実装したexploitは以下のようになりました。

```python
n = 95593382112797270045497836514999308524326160650345266525670495575191979116591752182138270308274446464071024826510473429700676303637674960212123982700153540490805215151070356646141514736282385755143090035980011032465519861526291865888128545478530962058792257703950616556136479933021373472378679162332202365371
c = 92084942302809419329882275131365664619817865820237979575321652348851871468885232665120732298048355621943772250718055278615366362227084559410831820721620242260588398786014654743749734106956509345330468686120026908164376320923131751798117799981744551407234489862207435686504148347452579942637697333568788391594
e = 65537
x = 18247071175606431398122118602371784578875472790915317892207044424588309397797319375039984309368393267673885302107217184699052743790470091033147110959310433418937324145720036262540098007724458652548486534453030546582214242131458903058169536052488501597969216020092796160475487905223265691093061136660574497410399108890645909789835984721231354187679269066357591297035974333220513134895660609801438138623213711900681512310067292949714127564635579383633589101296120704659647911638787823818973909534106275908594589830353183557722172234952579827423906720754070119865452363350814918812923981729393142874903734028229195885438296963982680724071663211427931391032589901737528717167662646147224323491202696402122261699504048973334902281462240308032014697804531871922566779026958815207465755155123070196922127199447785648102152027431894178737946151518726929361221425189695069653652163012000609320105988830299015364692678902927254273154427301473090465612473379114039284029813071586214536353994345527805408387636097772645156970939979500155578289301143563369142329343932852167241705090287661795

sympy.var("P")
s = sympy.solve(((P**5)*(n**2))+5*((n**2)*(P**4))+10*((n**2)*(P**3))+5*((n**2)*(P**2))+5*((n**2)*P)+n**2-(P**2)*x,P)
p = s[0]
int(p)
q = n // p
d = inverse(e, int((p - 1) * (q - 1)))
pn = pow(c, d,n)
print(long_to_bytes(pn))
```
<br>

## 振り返り
webを得意分野にするべく勉強しているのに、webの問題が全然解けないのがとても悔しかった。
cryptoは最近hack the boxで勉強していたのでこの３つは解くことができた。次への課題は、web問題を解けるようになることと、行列の勉強をすること。
それから、取り組んだけど解けなかった問題について、振り返りの記事を出す。



